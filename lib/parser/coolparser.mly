/* coolparser.mly */

%{
(*
 * Generated by coolparser.mly
 *
 * Grammar for the Classroom Object-Oriented Language (COOL).
 *)

open Util
open Helpers

let get_line_num n =
  (Parsing.rhs_start_pos n).pos_lnum

let make_single ~f ~x n =
  get_line_num n |> Ast.make_single ~f ~x

let make_double ~f ~x ~y n =
  get_line_num n |> Ast.make_double ~f ~x ~y

let make_untyped_expr ~exp n =
  get_line_num n |> Ast.make_untyped_expr ~exp

let print_error_item n =
  Astprint.print_error_item (Parsing.rhs_start_pos n) (Parsing.rhs_end_pos n)
%}

// tokens

%token ELSE FI IN INHERITS LOOP POOL THEN ESAC OF DARROW ASSIGN
%token LET AT COMMA COLON SEMI LPAREN RBRACE RPAREN EOF IF
%token WHILE LBRACE CASE NEW ISVOID CLASS DOT
%token PLUS MINUS MULT DIV LE LT EQ NEG NOT

%token <string> ERR
%token <Util.Tbl.handle> TYPEID OBJECTID STR_CONST INT_CONST
%token <bool> BOOL_CONST

// precedences

%right ASSIGN
%right NOT
%nonassoc LE LT EQ
%left PLUS MINUS
%left MULT DIV
%nonassoc ISVOID
%right NEG
%nonassoc AT
%left DOT

// start symbol

%start parse
%type <Ast.class_list option * bool> parse

%%

// rules

parse : classes { $1, false }
      | EOF { None, true }
      ;

classes : class_list { map_opt ~f:List.rev $1 }
        | error { print_error_item 1; None }
        ;

class_list  : { Some [] }
            | class_list clazz { merge $2 $1 }
            ;

clazz : CLASS TYPEID parent_class LBRACE feature_list RBRACE SEMI {
          let pos = Parsing.symbol_start_pos () in
          map_opt2 ~f:(fun parent features -> {
              Ast.class_type = $2;
              Ast.class_parent = parent;
              Ast.class_features = List.rev features;
              Ast.class_filename = Tables.make_str pos.pos_fname;
            },
            get_line_num 1)
          $3 $5
        }
      ;

parent_class  : { Some Tables.object_type }
              | INHERITS TYPEID { Some $2 }
              | error { print_error_item 1; None }
              ;

feature_list  : { Some [] }
              | feature_list feature SEMI { merge $2 $1 }
              | feature_list error SEMI { print_error_item 2; None }
              ;

feature : field { $1 }
        | mthd { $1 }
        ;

field : OBJECTID COLON TYPEID init { map_opt ~f:(fun exp -> Ast.Field ($1, $3, exp), get_line_num 1) $4 }
      ;

init  : { Some Ast.no_expr }
      | ASSIGN expr { $2 }
      ;

mthd  : OBJECTID LPAREN formal_list_or_empty RPAREN COLON TYPEID LBRACE unsafe_expr RBRACE {
          map_opt2 ~f:(fun args exp ->
            Ast.Method {
              method_id = $1;
              method_args = List.rev args;
              method_ret_type = $6;
              method_body = exp;
            },
            get_line_num 1)
          $3 $8
        }
      ;

formal_list_or_empty  : { Some [] }
                      | formal_list { $1 }
                      ;

formal_list : formal { singleton $1 }
            | formal_list COMMA formal { merge $3 $1 }
            ;

formal  : OBJECTID COLON TYPEID { Some (($1, $3), get_line_num 1) }
        ;

expr  : OBJECTID ASSIGN expr { make_single ~f:(fun e -> Assign ($1, e)) ~x:$3 1 }
      | OBJECTID ASSIGN error { print_error_item 3; None }
      | OBJECTID arg_list_or_empty {
          map_opt ~f:(fun args ->
            make_untyped_expr ~exp:(
              DynDispatch {
                dyn_recv = make_untyped_expr ~exp:(Variable Tables.self_var) 1;
                dyn_method = $1;
                dyn_args = List.rev args;
              })
            1)
          $2
        }
      | expr DOT OBJECTID arg_list_or_empty {
          map_opt2 ~f:(fun recv args ->
            make_untyped_expr ~exp:(
              DynDispatch {
                dyn_recv = recv;
                dyn_method = $3;
                dyn_args = List.rev args;
              })
            2)
          $1 $4
        }
      | expr AT TYPEID DOT OBJECTID arg_list_or_empty {
          map_opt2 ~f:(fun recv args ->
            make_untyped_expr ~exp:(
              StaticDispatch {
                stat_recv = recv;
                stat_type = $3;
                stat_method = $5;
                stat_args = List.rev args;
              })
            4)
          $1 $6
        }
      | IF unsafe_expr THEN unsafe_expr ELSE unsafe_expr FI {
          match $2, $4, $6 with
          | Some e1, Some e2, Some e3 ->
            Some (make_untyped_expr ~exp:(Cond (e1, e2, e3)) 1)
          | _ -> None
        }
      | WHILE unsafe_expr LOOP unsafe_expr POOL { make_double ~f:(fun e1 e2 -> Loop (e1, e2)) ~x:$2 ~y:$4 1 }
      | LBRACE expr_list RBRACE { make_single ~f:(fun es -> Block (List.rev es)) ~x:$2 1 }
      | LET binding_list IN expr %prec ASSIGN { map_opt2 ~f:Ast.make_let $2 $4 }
      | CASE unsafe_expr OF branch_list ESAC {
          make_double ~f:(fun exp cases -> Case (exp, List.rev cases)) ~x:$2 ~y:$4 1
        }
      | NEW TYPEID { Some (make_untyped_expr ~exp:(New $2) 1) }
      | ISVOID expr { make_single ~f:(fun exp -> IsVoid exp) ~x:$2 1 }
      | expr PLUS expr { make_double ~f:(fun e1 e2 -> Add (e1, e2)) ~x:$1 ~y:$3 2 }
      | expr MINUS expr { make_double ~f:(fun e1 e2 -> Sub (e1, e2)) ~x:$1 ~y:$3 2 }
      | expr MULT expr { make_double ~f:(fun e1 e2 -> Mult (e1, e2)) ~x:$1 ~y:$3 2 }
      | expr DIV expr { make_double ~f:(fun e1 e2 -> Div (e1, e2)) ~x:$1 ~y:$3 2 }
      | NEG expr { make_single ~f:(fun exp -> Neg exp) ~x:$2 1 }
      | expr LT expr { make_double ~f:(fun e1 e2 -> Lt (e1, e2)) ~x:$1 ~y:$3 2 }
      | expr LE expr { make_double ~f:(fun e1 e2 -> Le (e1, e2)) ~x:$1 ~y:$3 2 }
      | expr EQ expr { make_double ~f:(fun e1 e2 -> Eq (e1, e2)) ~x:$1 ~y:$3 2 }
      | NOT expr { make_single ~f:(fun exp -> Not exp) ~x:$2 1 }
      | LPAREN expr RPAREN { $2 }
      | OBJECTID { Some (make_untyped_expr ~exp:(Variable $1) 1) }
      | INT_CONST { Some (make_untyped_expr ~exp:(IntConst $1) 1) }
      | STR_CONST { Some (make_untyped_expr ~exp:(StrConst $1) 1) }
      | BOOL_CONST { Some (make_untyped_expr ~exp:(BoolConst $1) 1) }
      ;

unsafe_expr : expr { $1 }
            | error { print_error_item 1; None }
            ;

binding_list  : binding { singleton $1 }
              | binding_list COMMA binding { merge $3 $1 }
              ;

binding : OBJECTID COLON TYPEID init { map_opt ~f:(fun exp -> ($1, $3, exp, get_line_num 1)) $4 }
        | error { print_error_item 1; None }
        ;

branch_list : branch { singleton $1 }
            | branch_list branch { merge $2 $1 }
            ;

branch  : OBJECTID COLON TYPEID DARROW unsafe_expr SEMI {
            map_opt ~f:(fun exp -> ($1, $3, exp), get_line_num 1) $5
          }
        ;

arg_list_or_empty : LPAREN RPAREN { Some [] }
                  | LPAREN arg_list RPAREN { $2 }
                  ;

arg_list  : unsafe_expr { singleton $1 }
          | arg_list COMMA unsafe_expr { merge $3 $1 }
          ;

expr_list : unsafe_expr SEMI { singleton $1 }
          | expr_list unsafe_expr SEMI { merge $2 $1 }
          ;
