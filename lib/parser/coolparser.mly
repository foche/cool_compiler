/* coolparser.mly */

%{
(*
 * Generated by coolparser.mly
 *
 * Grammar for the Classroom Object-Oriented Language (COOL).
 *)

open Util
open Helpers

let get_line_num n =
  (Parsing.rhs_start_pos n).pos_lnum

let make_single ~f ~x n =
  get_line_num n |> Ast.make_single ~f ~x

let make_double ~f ~x ~y n =
  get_line_num n |> Ast.make_double ~f ~x ~y

let make_untyped_expr ~exp n =
  get_line_num n |> Ast.make_untyped_expr ~exp

let err_unclosed tok n =
  Astprint.err_unclosed tok (Parsing.rhs_start_pos n) (Parsing.rhs_end_pos n);
  None

let err_expected msg n =
  Astprint.err_expected msg (Parsing.rhs_start_pos n) (Parsing.rhs_end_pos n);
  None
%}

// tokens

%token ELSE FI IN INHERITS LOOP POOL THEN ESAC OF DARROW ASSIGN
%token LET AT COMMA COLON SEMI LPAREN RBRACE RPAREN EOF IF
%token WHILE LBRACE CASE NEW ISVOID CLASS DOT
%token PLUS MINUS MULT DIV LE LT EQ NEG NOT

%token <string> ERR
%token <string> TYPEID OBJECTID STR_CONST INT_CONST
%token <bool> BOOL_CONST

// precedences

%nonassoc let_prec
%right ASSIGN
%right NOT
%nonassoc LE LT EQ
%left PLUS MINUS
%left MULT DIV
%nonassoc ISVOID
%right NEG
%nonassoc AT
%nonassoc DOT

// start symbol

%start parse
%type <Ast.class_list option * bool> parse

%%

// rules

parse : classes { $1, false }
      | EOF { None, true }
      ;

classes : class_list { map_opt ~f:(fun cls -> Some (List.rev cls)) $1 }
        ;

class_list  : { Some [] }
            | class_list clazz SEMI { merge $2 $1 }
            | class_list clazz error { err_expected "\";\" after a class definition" 3 }
            ;

clazz : CLASS TYPEID parent_class features {
          let pos = Parsing.symbol_start_pos () in
          map_opt2 ~f:(fun parent features -> Some ({
              Ast.class_type = Tables.make_type $2;
              Ast.class_parent = parent;
              Ast.class_features = List.rev features;
              Ast.class_filename = Tables.make_str pos.pos_fname;
            },
            get_line_num 1))
          $3 $4
        }
      | CLASS error parent_class features { err_expected "a class name after \"class\"" 2 }
      ;

parent_class  : { Some Tables.object_type }
              | INHERITS TYPEID { Some (Tables.make_type $2) }
              | INHERITS error { err_expected "a class name after \"inherits\"" 2 }
              ;

features  : LBRACE feature_list RBRACE { $2 }
          | LBRACE feature_list error { err_unclosed "{" 3 }
          ;

feature_list  : { Some [] }
              | feature_list feature SEMI { merge $2 $1 }
              | feature_list feature error {
                  err_expected "\";\" after a field or method definition" 3
                }
              ;

feature : field { $1 }
        | mthd { $1 }
        ;

field : OBJECTID COLON TYPEID init {
          map_opt ~f:(fun exp ->
              Some (Ast.Field (Tables.make_id $1, Tables.make_type $3, exp), get_line_num 1))
            $4
        }
      ;

init  : { Some Ast.no_expr }
      | ASSIGN expr { $2 }
      ;

mthd  : OBJECTID formals COLON TYPEID LBRACE expr RBRACE {
          map_opt2 ~f:(fun args exp ->
            Some (Ast.Method {
              method_id = Tables.make_id $1;
              method_args = List.rev args;
              method_ret_type = Tables.make_type $4;
              method_body = exp;
            },
            get_line_num 1))
          $2 $6
        }
      ;

formals : LPAREN RPAREN { Some [] }
        | LPAREN formal_list RPAREN { $2 }
        | LPAREN error { err_unclosed "(" 2 }
        | LPAREN formal_list error { err_unclosed "(" 3 }

formal_list : formal { singleton $1 }
            | formal_list COMMA formal { merge $3 $1 }
            | formal_list error formal { err_expected "\",\" between formal arguments" 2 }
            ;

formal  : OBJECTID COLON TYPEID {
            Some ((Tables.make_id $1, Tables.make_type $3), get_line_num 1)
          }
        ;

expr  : OBJECTID ASSIGN expr {
          make_single ~f:(fun e -> Assign (Tables.make_id $1, e)) ~x:$3 1
        }
      | OBJECTID ASSIGN error { err_expected "an expression" 3 }
      | OBJECTID args {
          map_opt ~f:(fun args ->
            Some (make_untyped_expr ~exp:(
              DynDispatch {
                dyn_recv = make_untyped_expr ~exp:(Variable Tables.self_var) 1;
                dyn_method = Tables.make_id $1;
                dyn_args = List.rev args;
              })
            1))
          $2
        }
      | expr DOT OBJECTID args {
          map_opt2 ~f:(fun recv args ->
            Some (make_untyped_expr ~exp:(
              DynDispatch {
                dyn_recv = recv;
                dyn_method = Tables.make_id $3;
                dyn_args = List.rev args;
              })
            2))
          $1 $4
        }
      | expr AT TYPEID DOT OBJECTID args {
          map_opt2 ~f:(fun recv args ->
            Some (make_untyped_expr ~exp:(
              StaticDispatch {
                stat_recv = recv;
                stat_type = Tables.make_type $3;
                stat_method = Tables.make_id $5;
                stat_args = List.rev args;
                stat_label = None;
              })
            4))
          $1 $6
        }
      | IF expr THEN expr ELSE expr FI {
          match $2, $4, $6 with
          | Some e1, Some e2, Some e3 ->
            Some (make_untyped_expr ~exp:(Cond (e1, e2, e3)) 1)
          | _ -> None
        }
      | WHILE expr LOOP expr POOL { make_double ~f:(fun e1 e2 -> Loop (e1, e2)) ~x:$2 ~y:$4 1 }
      | LBRACE expr_list RBRACE { make_single ~f:(fun es -> Block (List.rev es)) ~x:$2 1 }
      | LET binding_list IN expr %prec let_prec {
          map_opt2 ~f:(fun bindings exps -> Some (Ast.make_let bindings exps)) $2 $4
        }
      | CASE expr OF branch_list ESAC {
          make_double ~f:(fun exp cases -> Case (exp, List.rev cases)) ~x:$2 ~y:$4 1
        }
      | NEW TYPEID { Some (make_untyped_expr ~exp:(New (Tables.make_type $2)) 1) }
      | ISVOID expr { make_single ~f:(fun exp -> IsVoid exp) ~x:$2 1 }
      | expr PLUS expr { make_double ~f:(fun e1 e2 -> Arith (Add, e1, e2)) ~x:$1 ~y:$3 2 }
      | expr MINUS expr { make_double ~f:(fun e1 e2 -> Arith (Sub, e1, e2)) ~x:$1 ~y:$3 2 }
      | expr MULT expr { make_double ~f:(fun e1 e2 -> Arith (Mul, e1, e2)) ~x:$1 ~y:$3 2 }
      | expr DIV expr { make_double ~f:(fun e1 e2 -> Arith (Div, e1, e2)) ~x:$1 ~y:$3 2 }
      | NEG expr { make_single ~f:(fun exp -> Neg exp) ~x:$2 1 }
      | expr LT expr { make_double ~f:(fun e1 e2 -> Comp (Lt, e1, e2)) ~x:$1 ~y:$3 2 }
      | expr LE expr { make_double ~f:(fun e1 e2 -> Comp (Le, e1, e2)) ~x:$1 ~y:$3 2 }
      | expr EQ expr { make_double ~f:(fun e1 e2 -> Eq (e1, e2)) ~x:$1 ~y:$3 2 }
      | NOT expr { make_single ~f:(fun exp -> Not exp) ~x:$2 1 }
      | LPAREN expr RPAREN { $2 }
      | LPAREN expr error { err_unclosed "(" 3 }
      | OBJECTID { Some (make_untyped_expr ~exp:(Variable (Tables.make_id $1)) 1) }
      | INT_CONST { Some (make_untyped_expr ~exp:(IntConst (Tables.make_int $1)) 1) }
      | STR_CONST { Some (make_untyped_expr ~exp:(StrConst (Tables.make_str $1)) 1) }
      | BOOL_CONST { Some (make_untyped_expr ~exp:(BoolConst $1) 1) }
      ;

binding_list  : binding { singleton $1 }
              | binding_list COMMA binding { merge $3 $1 }
              ;

binding : OBJECTID COLON TYPEID init {
            map_opt ~f:(fun exp ->
                Some (Tables.make_id $1, Tables.make_type $3, exp, get_line_num 1))
              $4
          }
        ;

branch_list : branch { singleton $1 }
            | branch_list branch { merge $2 $1 }
            ;

branch  : OBJECTID COLON TYPEID DARROW expr SEMI {
            map_opt ~f:(fun exp ->
                Some ((Tables.make_id $1, Tables.make_type $3, exp), get_line_num 1))
              $5
          }
        ;

expr_list : expr SEMI { singleton $1 }
          | expr_list expr SEMI { merge $2 $1 }
          | expr error { err_expected "\";\" at the end of an expression" 2 }
          | expr_list expr error { err_expected "\";\" at the end of an expression" 3 }
          ;

arg_list  : expr { singleton $1 }
          | arg_list COMMA expr { merge $3 $1 }
          | arg_list error expr { err_expected "\",\" between method arguments" 2 }
          | arg_list COMMA error { err_expected "a method argument after \",\"" 3 }
          ;

args  : LPAREN RPAREN { Some [] }
      | LPAREN arg_list RPAREN { $2 }
      | LPAREN error { err_unclosed "(" 2 }
      | LPAREN arg_list error { err_unclosed "(" 3 }
      ;
